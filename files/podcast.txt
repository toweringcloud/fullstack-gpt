So you have an idea for a startup you want to build and you're about to get started writing code. You know what you're going to use for the front end, for the back end, you have the UI design, you have it all. There is just one thing to figure out, the database. You know you're going to use SQL, but which flavor of SQL are you going to go for? That is what I want to help you figure out on this video, where we are going to take the three most popular SQL databases, SQLite, MySQL, and PostgreSQL, and we're going to compare them and find out in which case you would use one over the other. In the world of SQL databases, even though they all use the same language, SQL, that doesn't mean that they are all the same and that you can use them interchangeably. The truth is that SQL is a language that has many flavors. The way we write SQL commands can look the same syntax-wise, but the command themselves can be different depending on the database, or a feature that is in the SQL standard may be supported by a database but not by another. Because they are not interchangeable, it's important to choose the right database for your project at the start, so you don't have to migrate your data and write a bunch of code if you find out later that you need to change database. This video will of course only make sense if you already know SQL. If you don't know SQL, then what are you doing? Some may disagree, but I think that if you are in tech, whether you are a developer or not, not knowing SQL is leaving money on the table. Data is the new oil. With AI and everything else, the tech industry is even more hungry for data than ever before. The reason why Instagram, Twitter, and the rest are so valuable and free to use is because of the data they have and the data they mine from you and me. Data lives in databases, and most of the time databases speak SQL. Learning SQL has literally no downside. It can only level you up in whatever career you are in. SQL is incredibly old, which in tech is a good thing, because it means it has been around for a long time and it is not going anywhere. You can learn SQL for free if you want. There are tons of free resources online. But if you want to learn it quick, the most useful parts, and the things you are going to use the in your projects, click the link below to check out the SQL Masterclass course, where you will learn SQL while experiencing it across different database systems. We are going to score databases in two dimensions. First, how powerful they are, that means the features they support and what they can do. Can my project grow without a problem, or is there a limit I'm afraid I will hit? And second, how easy they are to use, which means how easy they are to install, manage, and maintain over time. The second dimension is arguably the most important one. Building a product with the latest, shiniest, and most powerful database sounds fun, but it is after you launch your product that you start to appreciate the value of working with a database that is easy to maintain. One thing to know is that I don't really care about how fast databases are. At the end of the day, they are all fast enough. Obsessing over which database can handle millions of requests per second, when most products won't even get a thousand requests per minute, is a waste of time. SQLite is a database I made a whole video about, because I think it is a misunderstood database, in part thanks to the name. People think the light in SQLite means that it is not powerful, can't handle lots of data, and is only suitable for toy projects, which isn't true. The light in SQLite has nothing to do with power. SQLite can easily handle millions of rows, gigabytes of data, and thousands of requests.
per second, if not more. Light actually stands for how lightweight it is, how little resources it uses, how easy it is to install, backup, and use. It is so lightweight that it is inside of every phone, airplane, smartwatch, and IoT device. I say that SQLite is the database of freedom, because compared to MySQL and PostgreSQL, it lets you do almost whatever you want, while supporting all, if not all, of the SQL features your application could need. For example, this is how you can create a table in SQLite. You don't even have to specify the column types. You just give them a name and can later save in those columns whatever data you want. If you like type enforcement, as I do, you can specify the type of columns and create a table with a strict keyword like this. And again, leaving up to its name, SQLite does not need to support many types. The types it supports are NULL, INTEGER, REAL, TEXT, and BLOB. NULL, INTEGER, and TEXT we know what they are. REAL is a floating point number and BLOB means binary large object, which is just a blob of data when you may need to store a file, for example. It may be shocking for some of you, but not having many times to choose from can actually be a good thing. It keeps things simple, easy to remember, and you actually can get very very far with just INTEGER, REAL, TEXT, and BLOB. My favorite thing about SQLite is that it doesn't require all the maintenance tasks that MySQL and PostgreSQL need. Because an SQL database is just a file, a file you can copy paste, a file you can email or put in a USB stick, backing up and restoring an SQL database is trivial. You can do as I've done and make a script that will email you a copy of the database every day at midnight, or upload the file to a cloud storage service like Dropbox, Google Drive, or AWS S3. The storage space of an SQL database is as big as the server that hosts the file. So if you have a server of 1TB of storage, your database has a storage capacity of 1TB. And if you need more space, just copy paste the file to a new server and you are good to go. Since it is just a file, your database can live in the same server where your application code also lives, which will be faster and cheaper than having a database on a separate server, since your code does not need to make a network request to get data from the database. There are very few things I hate more than database maintenance, and thanks to SQLite, I do none of that. If you are like me and you hate dealing with database servers, permissions, versions, backups, migrations, upgrades, and all that, then you will love SQLite. SQLite isn't perfect, like not being suitable for applications with multiple servers, which can be a dealbreaker for some. Check out the full SQLite video for more detail. Score-wise, SQLite is a 3 out of 5 in the power dimension, and an absolute 5 in ease of use. 3 out of 5 sounds low, but it's actually a very good score. The reason why it's a 3 is because later we have to score PostgreSQL, which is an absolute beast. Next up is MySQL, which, to be honest, is on this video just because of how popular it is. I don't really care for it, I don't love it or hate it, and for a long time I have not used it. It's a solid database, it used to be really popular before, which is why if you go to a big old company, chances are they are using MySQL. It supports more SQL features than SQLite, thus, like all the alter table commands, data and data types, JSON, and more. I will piss off a lot of people, but compared to PostgreSQL, MySQL looks like a legacy database. Being legacy can be good, because you know there are jobs that need it, there are lots of books, courses, questions and answers, the documentation is very good, and you will find drivers for it in almost every programming language.
MySQL was bought by Oracle, which is a company that loves to make money with their own enterprise database, Oracle Database. So it makes sense for Oracle to not be interested in developing MySQL into the most innovative and powerful database product it can be, and instead focus on developing and selling Oracle Database. That does not mean that MySQL is abandoned or something, it receives updates and bug fixes constantly. And like I said before, it's still very popular. Some people may be wary of using MySQL because it is owned by Oracle, which is a company famous for high-profile lawsuits over software, like the Oracle vs Google case over the use of Java in Android, as well as having hardcore licensing terms. The creator of MySQL actually left the project when Oracle bought it, forked it, and created MariaDB because of worries about licensing issues and fear of changes to its open-source model. Having said all this, there is one good reason to use MySQL and that is PlanetScale, which is a MySQL database platform that has the best developer experience of any database platform I have ever seen. Server-wise, MySQL is a solid 4 out of 5 in the power dimension, and a 4 out of 5 in ease of use and maintenance. It is more powerful than SQLite, but since it is a full-blown database system, it is much more complex than having a single SQLite database file. It needs a server, much more resources, it's more expensive to run, and tasks like backups, upgrades, migrations are much more complicated than in SQLite. Finally, PostgreSQL, the world's most advanced open-source database. PostgreSQL is at its peak of popularity right now, and with good reason. It is the most used database according to the Stack Overflow Developer Survey, and it's also the most desired to work with and admired by developers, followed by SQLite. Let's cut to the chase. PostgreSQL is a 5 out of 5 in the power dimension, maybe even 6 out of 5. It overflows the scale, and the reason why is because of PostgreSQL extensions. Yes, it may have more functions than MySQL here and there, but the extensions are what takes it to the next level. PostgreSQL extensions allow you to make your database do things that it couldn't do before. They are like plugins that you enable, and suddenly your database gets new types, new functions, operators, commands, and even new syntax. Like the HSTORE extension, for example, that turns your PostgreSQL into a NoSQL key-value store. You enable it by doing create extension HSTORE, and then you can create a table with the HSTORE type like this, to then save a product like this, to be able to search for a product like this, or if you want to get your mind blown, check out the PLPython3U extension. That allows you to literally write Python code in your SQL queries. This is something we actually learn in the SQL Masterclass course, where we enable the extension by doing create extension PLPython3U, and then proceed to write a database trigger function that hits our API when there is a change in our database. That is insane! We make our database run Python code! Crazy! We can literally tell PostgreSQL to hit our API when a new user creates an account to send a welcome email. Crazy! We have extensions for almost everything you need. pgVector, that turns PostgreSQL into a vector database. Super useful for AI. PostGIS for geospatial data. pgCrunch.
One to schedule jobs from within your database, PGJWT to create and verify JWT tokens, PGTAP to unit test your database, and the many many other extensions that you can discover in websites like PGNX.org PostgreSQL takes the crown for the most powerful database but also for the most complex one, so it is a 5 out of 5 in the power dimension and a 3 out of 5 in the ease of use. Just because it is so complex and with extensions, it ends up with even more moving parts. Personally, whenever I start a project I go for either SQLite or PostgreSQL, I either use the minimalist, lightweight, easy-to-maintain SQLite, or I use the most incredible and heavy workhorse that is PostgreSQL. It is very easy to overestimate how much database power your project is going to need, because we all think we are building the next Instagram, and it is very easy to underestimate the absolute pain that is maintaining a full-blown database once you have users and need to do backups, migrations, and upgrades. Most of the time I am okay sacrificing power for simplicity, so I go for SQLite, except for when I need to do something that is not supported by SQLite, like having a vector database or full JSON support, which is when I go for PostgreSQL. This is of course my opinion and there is a very big chance I am wrong, and you have a different experience and opinion than mine, which is completely fine. And of course, the best way to learn and see which opinion is the most accurate is to try it out by yourself. Go build something awesome, use different databases, and see how you like them. Thank you for watching as always, smash the like button if you liked the video, share it with your friends, and subscribe to the channel. On general, kam sa hago, sa ran hamida, see you on the next one, check out the SQL Masterclass course, link in the description. See you in the next one. Bye bye.
